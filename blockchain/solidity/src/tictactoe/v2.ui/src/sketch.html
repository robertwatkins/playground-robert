<!DOCTYPE html>
<html>
<title>Tic Tac Toe</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script type="text/javascript" src="web3.min.js"></script>
<style>
html,body,h1,h2,h3,h4,h5 {font-family: "Raleway", sans-serif}
</style>
<body class="w3-light-grey">

<!-- Top container -->
<div class="w3-bar w3-top w3-black w3-large" style="z-index:4">
  <span class="w3-bar-item w3-right">Brought to you by Red Earth Security</span>
</div>

<div class="w3-main" style="margin-top:43px;">
  <!-- Header -->
  <header class="w3-container" style="padding-top:22px">
      <h1>Tic Tac Toe</h1>
  </header>
  <div class="w3-center" >
  <div class="w3-row-padding w3-margin-bottom">
    <div class="w3-half">
      <div class="w3-container w3-blue w3-padding-16">
        <div class="w3-left"><i class="fa fa-user-circle-o w3-xxxlarge"></i></div>
        <div class="w3-right">
          <h3>You (O)</h3>
        </div>
        <div class="w3-clear"></div>
        <h4>[Your Name]</h4><input id="o-player-address" value="0x2C26D29abA30e555eD4f25A3F3F800c0Cdc15776"><input type="button" value="Start">
      </div>
    </div>
    <div class="w3-half">
      <div class="w3-container w3-teal w3-padding-16">
        <div class="w3-left"><i class="fa fa-user-circle w3-xxxlarge"></i></div>
        <div class="w3-right">
          <h3>Opponent (X)</h3>
        </div>
        <div class="w3-clear"></div>
          <h4>[Opponent Name]</h4><input id="x-player-address" value="0x31b6Fd2AC4Bf067BC5B0EB3B1b7c92f7b9acCB97"/>
          <input type="button" value="Join">
          <div id="balance"></div>
      </div>
    </div>
  </div>
    <div class="w3-row-padding w3-margin-bottom">
        <div class="w3-half ">
            <div class="w3-container w3-padding-16">
                <canvas id="tictactoeboard" width="300" height="300"></canvas>
            </div>
        </div>
        <div class="w3-half">
          <div class="w3-container w3-indigo w3-padding-16">
            <div class="w3-clear">
              <h3 id="currentPlayerIndicator">Waiting</h3>
            </div>
            <div class="w3-clear"></div>
            <h4 id="currentPlayerIndicatorAddendum">to start game</h4><input id="address" value="0x0a8719e03f24703383160cb9e4cc0e391e71c8a4">
          </div>
        </div>
      </div>
  </div>   
  <hr>
  <!-- End page content -->
</div>

<script>
    //By convention the smart contract will use '0x00' for a space not played, '0x11' for 'X' and '0xAA' for 'O', 'CAT' (0xFF).
    var currentPlayerTurn = "X";
    var currentMoves = ["","","","","","","","",""];
    var scale = 300;
    var width = scale / 20;
    var boardColor = 'black';
    var xColor = '#009688';
    var oColor = '#2196F3';
    var fillColor = 'white';
    var c = document.getElementById("tictactoeboard");
    var ctx = c.getContext("2d");
    c.addEventListener('mousemove', function(evt) {
        var mousePos = getMousePos(c, evt);
        showTurn(mousePos.x, mousePos.y);
    }, false);
    c.addEventListener('click', function(evt) { 
        var mousePos = getMousePos(c, evt);
        makeMove(mousePos.x, mousePos.y);
    }, false);
    createBoard();
    drawCurrentMoves();
    
    
    //todo find example for connecting to network, calling contract with parameters
    //todo find a polling mechanism to keep status updated
    //http://hypernephelist.com/2016/06/21/a-simple-smart-contract-ui-web3.html
    
    //var web3 = new Web3(new Web3.providers.HttpProvider("http://127.0.0.1:7545"));

    //if (typeof web3 === 'undefined') {
    //  alert('You need to install MetaMask to use this feature.  https://metamask.io')
    //}
    //var game_address = "0x9686d33515d8854e3af39346c3c24c6042136ded"

//  web3.eth.sendTransaction({
//    to: game_address,
//    from: user_address,
//    value: web3.toWei('1', 'ether'),
//  }, function (err, transactionHash) {
//    if (err) return renderMessage('Oh no!: ' + err.message)

    // If you get a transactionHash, you can assume it was sent,
    // or if you want to guarantee it was received, you can poll
    // for that transaction to be mined first.
//    renderMessage('Thanks!')
//  }

window.addEventListener('load', function() {

    // Checking if Web3 has been injected by the browser (Mist/MetaMask)
    if (typeof web3 !== 'undefined') {
        // Use Mist/MetaMask's provider
        web3js = new Web3(web3.currentProvider);
    } else {
        console.log('No web3? You should consider trying MetaMask!')
        // fallback - use your fallback strategy (local node / hosted node +     in-dapp id mgmt / fail)
        web3js = new Web3(new Web3.providers.HttpProvider("http://localhost:7545"));
    }

    var user_address = web3js.eth.accounts[0];
    var balanceWei;
    console.log(user_address);
    user_address = "0x2C26D29abA30e555eD4f25A3F3F800c0Cdc15776";
    //use callbacks
    //https://github.com/ethereum/wiki/wiki/JavaScript-API#using-callbacks
    //old version-var balanceWei = web3js.eth.getBalance(user_address).toNumber();
    //new version below
    web3js.eth.getBalance(user_address, function(error, balanceWei){
   if(!error)
       console.log(JSON.stringify(balanceWei));
   else
       console.error(error);
    })
    
    var balance = web3js.fromWei(balanceWei, 'ether');
    balanceElement =  document.getElementById("balance");
    balanceElement.innerHTML = balance;


})


    function makeMove(x,y){
        var location = getLocationFromMousePosition(x, y);
        if (location >=0 && location <=8 ) {
            if(currentMoves[location]==""){
                currentMoves[location]=currentPlayerTurn;
                endCurrentPlayersTurn();
                createBoard();
                drawCurrentMoves();
            }
        }
    }
    
    function endCurrentPlayersTurn(){
        if (currentPlayerTurn == "X"){
            currentPlayerTurn = "O";
        } else {
            currentPlayerTurn = "X";
        }
        updateCurrentPlayerIndicator();
    }
    
    function updateCurrentPlayerIndicator(){
        var currentPlayerIndicator = document.getElementById("currentPlayerIndicator");
        currentPlayerIndicator.innerHTML = "Player " + currentPlayerTurn;
        
        var currentPlayerIndocatorAddendum = document.getElementById("currentPlayerIndicatorAddendum");
        currentPlayerIndicatorAddendum.innerHTML = "Turn";
        
    }
    
    
    function showTurn(x, y){
        ctx.clearRect(0, 0, c.width, c.height);
        createBoard();
        drawCurrentMoves();
        makeMarkUnderMouse(x, y);
    };

    function makeMarkUnderMouse(x, y){
        var location = getLocationFromMousePosition(x, y);
        if (location >=0 && location <=8 ) {
            if(currentMoves[location]==""){
                makeMarkAtLocation(currentPlayerTurn,location);
                //todo remove this and get move from other player makeMarkAtLocation("X",location);
            }
        }
    }
    
    function getLocationFromMousePosition(x, y){
        var location = -1;
        if (y < (scale/3)) {
            if (x < (scale/3)){
                location = 0;
            } else if(x < (2* scale / 3)){
                location = 1;
            } else {
                location = 2;
            }
        } 
        else if (y < (2 * scale / 3)) {
            if (x < (scale/3)){
                location = 3;
            } else if(x < (2* scale / 3)){
                location = 4;
            } else {
                location = 5;
            }
        } else {    
            if (x < (scale/3)){
                location = 6;
            } else if(x < (2* scale / 3)){
                location = 7;
            } else {
                location = 8;
            }
        }
        console.log(location);
        return location;
    }
    function drawCurrentMoves(){
        for (i=0; i<9 ; i++){
            makeMarkAtLocation(currentMoves[i],i);
        }
    }

    function checkPositioning() {    
        var myMark1 = "X";
        var myMark2 = "O";
        makeMarkAtLocation(myMark1,0);
        makeMarkAtLocation(myMark2,1);
        makeMarkAtLocation(myMark1,2);
        makeMarkAtLocation(myMark2,3);
        makeMarkAtLocation(myMark1,4);
        makeMarkAtLocation(myMark2,5);
        makeMarkAtLocation(myMark1,6);
        makeMarkAtLocation(myMark2,7);
        makeMarkAtLocation(myMark1,8);
    }

    function makeMarkAtLocation(mark, location) {
        xOffset = (location % 3) * (scale / 3) + (scale / 6);
        yOffset = Math.floor(location / 3) * (scale / 3) + (scale / 6);
        var c = document.getElementById("tictactoeboard");
        var ctx = c.getContext("2d");

        ctx.lineWidth = width;

        if (mark == "X"){
            ctx.beginPath();
            ctx.strokeStyle = xColor;
            ctx.moveTo(xOffset + (scale/9),yOffset + (scale/9));
            ctx.lineTo(xOffset - (scale/9),yOffset - (scale/9));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(xOffset + (scale/9),yOffset - (scale/9));
            ctx.lineTo(xOffset - (scale/9),yOffset + (scale/9));
            ctx.stroke();
        } else  if ( mark == "O") {
            ctx.beginPath();
            ctx.arc(xOffset, yOffset, scale/9 , 0, 2 * Math.PI, false);
            ctx.strokeStyle = oColor;
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.stroke();  
        } else {
            //no mark to be made
        }
    }

    function createBoard() {
        var c = document.getElementById("tictactoeboard");
        var ctx = c.getContext("2d");
        ctx.lineWidth = width;
        ctx.strokeStyle = boardColor;

        ctx.moveTo(scale/3, 0);
        ctx.lineTo(scale/3, scale);
        ctx.stroke(); 

        ctx.moveTo(2*scale/3, 0);
        ctx.lineTo(2*scale/3, scale);
        ctx.stroke(); 

        ctx.moveTo(0, scale/3);
        ctx.lineTo(scale, scale/3);
        ctx.stroke(); 

        ctx.moveTo(0, 2*scale/3);
        ctx.lineTo(scale, 2*scale/3);
        ctx.stroke(); 
    }

    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
    }    
</script>

</body>
</html>
